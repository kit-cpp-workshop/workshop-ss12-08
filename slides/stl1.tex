\section{STL-Datenstrukturen}

\subsection{Überblick}

\begin{frame}{Standard Template Library}
	Kurze Intro in die STL:
	Design-Grundsätze
	Funktionsumfang
	
	% Robert, wärst du so freundlich?
	
\end{frame}


\subsection{sequence containers}

\begin{frame}[fragile]{Überblick}
	Die STL stellt für die geordnete Speicherung von \enquote{Dingen} drei Containertypen bereit:
	\begin{itemize}
		\item \verb|vector|
		\item \verb|list|
		\item \verb|deque|
	\end{itemize}
	
	\pause
	
	Außerdem gibt es noch drei Adapter-Typen, die auf Basis dieser Container arbeiten:
	\begin{itemize}
		\item \verb|queue|
		\item \verb|priority_queue|
		\item \verb|stack|
	\end{itemize}
	
	\pause
	
	Diese werden in einem der nächsten Workshops besprochen.
\end{frame}

\begin{frame}[fragile]{Gemeinsame Eigenschaften/Funktionalität}
	\begin{itemize}
		\item Speichern Sequenzen von \enquote{Dinge}
		\begin{itemize}
			\item In der vorgegebenen Reihenfolge (Überraschung!)
			\pause
			\item Dynamisch, sie passen ihre Größe den Anforderungen an
		\end{itemize}
	\end{itemize}
	
	\pause
	
	Funktionsumfang:
	\begin{itemize}
		\item Zugriff über Iteratoren (mehr dazu später)
		\begin{itemize}
			\item Sowohl vorwärts als auch rückwärts
			\item Generell je Inkrement in $\mathcal{O}(1)$
		\end{itemize}
		\pause
		\item Elementzählung in $\mathcal{O}(1)$
		\pause
		\item Elementzugriff
		\begin{itemize}
			\item Anfang und Ende in $\mathcal{O}(1)$
			\item \verb|vector| und \verb|deque| auch Wahlfrei (in $\mathcal{O}(1)$)
		\end{itemize}
		\pause
		\item Modifikation: Einfügen, löschen und leeren
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Container: \texttt{vector}}
	\begin{block}{Abbildung: Struktur}
		TODO: Illustration Vector-Insert
	\end{block}

	\begin{itemize}
		\item Array-basiert
		\pause
		\begin{itemize}
			\item[+] Cache-effizient
			\item[+] (Direkt-)Zugriffe sehr schnell möglich: $\mathcal{O}(1)$
			\pause
			\item Wachstum erfordert Kopiervorgänge!
			\item[-] Einfügen/Entfernen ist teuer: $\mathcal{O}(n)$ (!)
			\begin{itemize}
				\item Ausnahme: Am Ende des \verb|vector|s (mit \verb|push_back|, \verb|pop_back|): $\mathcal{O}(1)$
			\end{itemize}
		\end{itemize}
		\pause
		\item Vor allem geeignet für Aufgaben mit wahlfreiem Zugriff und wenigen Änderungsoperationen die nicht am Ende stattfinden.
	\end{itemize}
\end{frame}
	
\begin{frame}[fragile]{Container: \texttt{list}}
	\begin{block}{Abbildung: Struktur}
		TODO: Illustration DLL-Insert
	\end{block}

	\begin{itemize}
		\item Zugrundeliegende Datenstruktur: Doppelt verlinkte Liste
		\pause
		\begin{itemize}
			\item[-] Schlechte Cache-Effizienz (Container können unzusammenhängend im Speicher liegen)
			\item[-] Kein Direktzugriff! Über Iteration in $\mathcal{O}(n)$ (!)
			\pause
			\item[+] Einfügen/Entfernen ist (bei gegebener Position) sehr schnell: $\mathcal{O}(1)$
			\item[+] Verschieben von Elementen in eine andere \verb|list| ist (in zwei Fällen) sehr schnell: \verb|splice| in $\mathcal{O}(1))$
			\item Bietet einige Zusatzmethoden zum sortieren und filtern
		\end{itemize}
		\pause
		\item Vor allem geeignet für Algorithmen mit einer großen Anzahl nichttrivialer Listenmodifikationen, solange kein wahlfreier Zugriff erforderlich ist.
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Container: \texttt{deque}}
	\begin{block}{Abbildung: Struktur}
		TODO: Illustration deque
	\end{block}
	
	\begin{itemize}
		\item Datenstruktur: Array-basiert ähnlich wie \verb|vector|, aber in kleine Blöcke unterteilt
		\pause
		\begin{itemize}
			\item[+] Cache-Effizienz: Zusammenhängende Blöcke $\rightarrow$ vermutlich gut
			\item[+] Direktzugriff: $\mathcal{O}(1)$
			\pause
			\item Wieder: Wachstum erfordert Kopieroperationen
			\item[-] Beliebiges Einfügen/Entfernen: $\mathcal{O}(n)$ (wie bei \verb|vector|)
			\begin{itemize}
				\item Ausnahme: An Anfang oder Ende der \verb|deque| (\verb|push|/\verb|pop_front|/\verb|back|): $\mathcal{O}(1)$
			\end{itemize}
		\end{itemize}
		\pause
		\item \verb|deque| ist etwas flexibler als \verb|vector|, hat aber auch einen größeren Verwaltungsoverhead. (Konstante Faktoren!)
	\end{itemize}
\end{frame}

\begin{frame}{Hilfe zur Selbsthilfe}
	Der C++-Standard ist die offizielle Referenz. 
	
	Die unten verlinkte Dokumentation ist in der Praxis aber
	\begin{itemize}
		\item mehr als ausreichend
		\item außerdem übersichtlich strukturiert
		\item bietet umfangreiche Erläuterungen
		\item und jede Menge Beispiele
	\end{itemize}
	
	\begin{center}
		\url{http://www.cplusplus.com/reference/stl/}
	\end{center}
\end{frame}


\subsection{Iteratoren}

% Robert, insert content here!

